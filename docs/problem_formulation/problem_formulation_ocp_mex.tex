\documentclass[english]{article}
\usepackage[plainpages=false, hypertexnames=true, breaklinks=true]{hyperref}
% General document formatting
\usepackage[margin=0.7in]{geometry}
\usepackage[parfill]{parskip}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

% Related to math
\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{booktabs}
% setup font
\usepackage{lmodern}
\usepackage{inconsolata}
%% this gives nicer fonts, comment \usepackage{amssymb} above
\usepackage[bitstream-charter,cal=cmcal]{mathdesign}
\usepackage[rmdefault]{mathcomp}
\usepackage{babel}

\usepackage[square,numbers]{natbib}
\bibliographystyle{abbrvnat}



%% if required this can be used to make landscape pages, e.g., for wide tables
% \usepackage{afterpage}
% \usepackage{ifpdf}
% \ifpdf
% % landscape mode, only pdf:
% \usepackage{pdflscape}
% % otherwise use:
% \else
% \usepackage{lscape}
% \fi

\usepackage{multirow}


\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\str}[1]{\texttt{'#1'}}
\newcommand{\casadi}{\texttt{CasADi}}
\newcommand{\acados}{\texttt{acados}}
\newcommand{\matlab}{\textsc{MATLAB}}
\newcommand{\python}{\textsc{Python}}
\newcommand{\tran}{^\top}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\abs}[1]{\left\lvert#1\right\rvert}
\newcommand{\ind}[1]{_{\textrm{#1}}}
\newcommand{\terminal}{^{\textrm{e}}}
\newcommand{\initial}{^{\textrm{0}}}
\newcommand{\matr}[1]{\begin{bmatrix}#1\end{bmatrix}}
\newcommand{\upind}[1]{\ensuremath{{^{\textrm{#1}}}}}
\newcommand{\glob}{_{\textrm{global}}}
% slack indices
\newcommand{\Lower}{\ind{l}}
\newcommand{\lowerh}{\ind{l,h}}
\newcommand{\lowerbx}{\ind{l,bx}}
\newcommand{\lowerbu}{\ind{l,bu}}
\newcommand{\lowerg}{\ind{l,g}}

\newcommand{\upper}{\ind{u}}
\newcommand{\upperh}{\ind{u,h}}
\newcommand{\upperbx}{\ind{u,bx}}
\newcommand{\upperbu}{\ind{u,bu}}
\newcommand{\upperg}{\ind{u,g}}

\newcommand{\mathComment}[1]{\texttt{/* #1 */}}
\newcommand{\R}{\mathbb{R}}

\newcommand{\nx}{n\ind{x}}
\newcommand{\nuu}{n\ind{u}}
\newcommand{\nz}{n\ind{z}}
\newcommand{\np}{n\ind{p}}
\newcommand{\ns}{n\ind{s}}

\newcommand{\mandatory}{yes}
\newcommand{\optional}{no}


\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}

% increase spacing between sections for improved readability
% \usepackage{titlesec}
% \titlespacing{\section}{0pt}{*5}{*1}

\begin{document}
%
\section{Problem Formulation}\label{sec:problem}
%
In \acados{}, one can formulate continuous-time optimal control problems (OCP) of the following form using the class \texttt{AcadosOcp}:
%
\begin{align}
% cost
    &&&\mathComment{Cost function, see section \ref{sec:cost}}\nonumber\\
    &\underset{\begin{subarray}{c}
        x(\cdot),\,u(\cdot), \, z(\cdot), \, s(\cdot), \, s\terminal
        \end{subarray}}{\min}
    &&\int_0^T l(x(t), u(t), z(t), t, p(t), p\glob)
     + \frac{1}{2} \matr{s\Lower(t) \\ s\upper(t) \\ 1} \tran
      \matr{ Z\Lower & 0 & z\Lower \\
      0 & Z\upper & z\upper \\
        {z\Lower}\tran & {z\upper}\tran & 0}
    \matr{s\Lower(t) \\ s\upper(t) \\ 1} \mathrm{d}t \; + \nonumber\\
     &&& \quad \quad m(x(T), z(T), p(T), p\glob) +
      \frac{1}{2} \matr{s\Lower\terminal \\ s\upper\terminal \\ 1} \tran
     \matr{ Z\Lower\terminal & 0 & z\Lower\terminal \\
         0 & Z\upper\terminal & z\upper\terminal \\
         {z\Lower\terminal}\tran & {z\upper\terminal}\tran & 0}
     \matr{s\Lower\terminal \\ s\upper\terminal \\ 1}
     \label{eq:cost}\\
    % constraints
    &&&\mathComment{Initial values, see section \ref{sec:constraints:initial}}\nonumber\\
    &\,\,\,\quad \text{s.t.}    &&\underline{x}_0 \leq J\ind{bx}\initial \, x(0) \leq \overline{x}_0 , && \label{eq:constraints:initial}\\[1ex]
    &&&\mathComment{Nonlinear constraints on the initial shooting node} \nonumber\\
    &&&\underline{h}\initial \leq h\initial(x(0), u(0), z(0), p(0), p\glob) + J_{\textrm{sh}}\initial \, s\lowerh\initial, &&\label{eq:constraints:path:lower_bounds:start}\\
    &&& h\initial(x(0), u(0),  z(0), p(0), p\glob) - J\ind{sh}\initial\, s\ind{u,h}\initial \leq \overline{h}\initial, &&\label{eq:constraints:path:upper_bounds:start}\\
    &&&\mathComment{Dynamics, see section \ref{sec:dynamics}}\nonumber\\
    %% dynamics
    &&& f\ind{impl}(x(t), \dot{x}(t), u(t), z(t), t, p(t), p\glob) = 0, &&\quad t \in [0,\,T), \label{eq:dynamics}\\[1ex]
    &&&\mathComment{Path constraints with lower bounds, see section \ref{sec:constraints:path}}\nonumber\\
    %% path constraints with lower slack
    &&&\underline{h} \leq h(x(t), u(t), z(t), p(t), p\glob) + J_{\textrm{sh}} \, s\lowerh(t), &&\quad t \in (0,\,T),\\
    &&&\underline{x} \leq J_{\textrm{bx}} \, x(t) + J_{\textrm{sbx}} \,s\lowerbx(t), &&\quad t \in (0,\,T),\\
    &&&\underline{u} \leq J_{\textrm{bu}} \,u(t) + J_{\textrm{sbu}} \,s\lowerbu(t), &&\quad t \in [0,\,T),\\
    &&&\underline{g} \leq C\,x(t) + D\,u(t) + J_{\textrm{sg}} \,s\lowerg(t), &&\quad t \in [0,\,T), \\
    &&& s\lowerh (t), s\lowerbx(t), s\lowerbu(t), s\lowerg(t) \geq 0, &&\quad t \in [0,\,T), \\
    &&& s\lowerh\initial \geq 0, && \label{eq:constraints:path:lower_bounds:end}\\[1ex]
    &&&\mathComment{Path constraints with upper bounds, see section \ref{sec:constraints:path}}\nonumber\\
    %% path constraints with upper slack
    &&& h(x(t), u(t), z(t), p(t), p\glob) - J_{\textrm{sh}} \, s\upperh(t) \leq \overline{h}, &&\quad t \in (0,\,T),\\
    &&& J_{\textrm{bx}} x(t) - J_{\textrm{sbx}}\, s\upperbx(t) \leq \overline{x}, &&\quad t \in (0,\,T),\\
    &&& J_{\textrm{bu}} u(t) - J_{\textrm{sbu}}\, s\upperbu(t)\leq \overline{u}, &&\quad t \in [0,\,T),\\
    &&& Cx(t) + Du(t) - J_{\textrm{sg}}\, s\upperg \leq \overline{g}, &&\quad t \in [0,\,T), \\
    &&& s\upperh(t), s\upperbx(t), s\upperbu(t), s\upperg(t) \geq 0, &&\quad t \in [0,\,T), \\
    &&& s\ind{u,h}\initial \geq 0, && \label{eq:constraints:path:upper_bounds:end}\\[1ex]
    %% lower terminal constraints
    &&&\mathComment{Terminal constraints with lower bounds, see section \ref{sec:constraints:path}}\nonumber\\
    &&&\underline{h}\terminal \leq h\terminal(x(T), p(T), p\glob) + J\ind{sh}\terminal\, s\lowerh\terminal, &&\label{eq:constraints:terminal:lower_bounds:start}\\
    &&&\underline{x}\terminal \leq J_{\textrm{bx}}\terminal\, x(T) + J\ind{sbx}\terminal\, s\lowerbx\terminal, &&\\ % TODO: add Jsbx_e?!
    &&&\underline{g}\terminal \leq C\terminal\, x(T) + J\ind{sg}\terminal\, s\lowerg\terminal \leq \overline{g}\terminal, && \\
    &&& s\lowerh\terminal, s\lowerbx\terminal, s\lowerbu\terminal, s\lowerg\terminal \geq 0, \label{eq:constraints:terminal:lower_bounds:end}\\[1ex]
    %% upper terminal constraints
    &&&\mathComment{Terminal constraints with upper bounds, see section \ref{sec:constraints:path}}\nonumber\\
    &&& h\terminal(x(T), p(T), p\glob) - J\ind{sh}\terminal\, s\ind{u,h}\terminal \leq \overline{h}\terminal, &&\label{eq:constraints:terminal:upper_bounds:start}\\
    &&& J_{\textrm{bx}}\terminal\, x(T) - J\ind{sbx}\terminal\, s\ind{u,bx}\terminal \leq \overline{x}^{e}, &&\\
    &&& C\terminal\, x(T) - J\ind{sg}\terminal\, s\ind{u,g}\terminal \leq \overline{g}\terminal \\
    &&& s\upperh\terminal, s\upperbx\terminal, s\upperbu\terminal, s\upperg\terminal \geq 0,\label{eq:constraints:terminal:upper_bounds:end}
\end{align}
%
with
\begin{itemize}
\item state vector $ x: \R \rightarrow \R^{\nx} $
\item control vector $ u: \R \rightarrow \R^{\nuu} $
\item algebraic state vector $ z: \R \rightarrow \R^{\nz} $
\item time-varying problem parameters $ p: \R \rightarrow \in \R^{\np}$
\item global problem parameters $p\glob  \in \R^{n_{p\glob}}$
\item slacks for initial constraints $s\ind{u,h}\initial \in \R^{\ns\initial}$ and $s\ind{l,h}\initial \in \R^{\ns\initial}$
\item slacks for path constraints $ s\Lower(t) = (s\lowerbu, s\lowerbx, s\lowerg, s\lowerh) \in \R^{\ns} $ and $ s\upper(t) = (s\upperbu, s\upperbx, s\upperg, s\upperh) \in \R^{\ns} $
\item slacks for terminal constraints $ s\Lower\terminal(t) = (s\lowerbx\terminal, s\lowerg\terminal, s\lowerh\terminal) \in \R^{\ns\terminal} $ and $ s\upper\terminal(t) = (s\upperbx\terminal, s\upperg\terminal, s\upperh\terminal) \in \R^{\ns\terminal} $
\item selection matrices $J_{\star}$, $J_{\mathrm{s}\star}$, i.e. they are all zeros except for a single one entry in each row.
\item diagonal matrices $Z\ind{l}, Z\ind{u}$, $Z\ind{l}\terminal, Z\ind{u}\terminal$
\end{itemize}

While the user specifies the OCP in continuous time, the problem is internally discretized using the \textbf{multiple shooting} approach and a piecewise constant parametrization for the control and parameter trajectory.
In particular, the algebraic variables returned by \acados{} are associated with the beginning of a shooting interval.
Thus, there are no algebraic variables available at the terminal node.

%

%
\paragraph{Document Purpose.}
This document describes the class of optimal control problems that can be formulated and solved in \acados{} via the class \texttt{AcadosOcp}, available in the \matlab{} and \python{} interfaces.
%Here, the focus is to give a mathematical overview of the problem formulation and possible options to model it within \acados.
This documentation is (most likely) not exhaustive and does not contain a full description of all options provided by the \python{} and \matlab{} interfaces.

In particular, this document does not cover the \acados{} problem formulation and interface for multi-phase OCP \cite{frey2024multi}.

%You can find examples in the directory \code{<acados>/examples/acados\_matlab\_octave}.
%The source code of the \acados{} \matlab{} interface is found in: \code{<acados>/interfaces/acados\_matlab\_octave} and should serve as a more extensive, complete and up-to-date documentation about the possibilities.

%\paragraph{Abbreviations.}
%Some of the following restrictions may apply to matrices in the formulation:
%\begin{center}
%	\begin{tabular}{ll}
%		\textbf{DIAG} & diagonal\\
%		\textbf{SPUM} & horizontal slice of a permuted unit matrix\\
%		\textbf{SPUME} & like \textbf{SPUM}, but with empty rows intertwined
%	\end{tabular}
%\end{center}


\section{Dynamics}\label{sec:dynamics}
%
% The system dynamics term is used to connect state trajectories from adjacent shooting nodes by means of equality constraints.
%
The system dynamics equation~\eqref{eq:dynamics} is internally replaced with a discrete-time dynamic system.
The dynamics can be formulated in different ways in \acados:
As implicit equations in continuous time~\eqref{eq:dynamics:implicit}, as explicit equations in continuous time~\eqref{eq:dynamics:explicit}, or directly as discrete-time dynamics \eqref{eq:dynamics:discrete}.
This section and Table~\ref{tab:dynamics} summarize these options.
%
\subsection{Implicit Dynamics}\label{sec:dynamics:implicit}
%
The most general way to provide a continuous-time ODE in \acados\ is to define the function $ f\ind{impl}: \mathbb{R}^{\nx}\times\mathbb{R}^{\nx}\times\mathbb{R}^{\nuu}\times\mathbb{R}^{\nz}\times\mathbb{R} \times \mathbb{R}^{\np} \rightarrow \mathbb{R}^{\nx+\nz}$ which is fully implicit DAE formulation describing the system as:
\begin{equation}
    f\ind{impl}(x, \dot{x}, u, z, t, p, p\glob) = 0.\label{eq:dynamics:implicit}
\end{equation}
\acados{} can discretize $ f\ind{impl} $ with a classical implicit Runge-Kutta (\code{'IRK'}), a structure exploiting implicit Runge-Kutta method (\code{'GNSF'}) \cite{Frey2019}, or a lifted-Newton direct collocation method (\code{'LIFTED\_IRK'}) \cite{Quirynen2015a}.
These discretization methods are set via \code{AcadosOcpOptions.integrator\_type}.
The implicit dynamics $f\ind{impl}$ need to be provided as a \casadi{} expression and set as \code{AcadosModel.f\_impl\_expr}.

\textbf{Note.} Time-varying dynamics are at the moment only available via the \python{} interface and only in combination with the classical implicit Runge-Kutta (\code{'IRK'}) integrator.
%
\subsection{Explicit Dynamics}\label{sec:dynamics:explicit}
%
Alternatively, \acados{} offers an explicit Runge-Kutta integrator (\code{'ERK'}), which can be used with explicit ODE models, i.e., models of the form
\begin{align}
f\ind{expl}(x,u,t,p, p\glob) &= \dot{x}.\label{eq:dynamics:explicit}
\end{align}
The explicit dynamics $f\ind{expl}$ need to be provided as a \casadi{} expression and set as \code{AcadosModel.f\_expl\_expr}.
The explicit integrator is used if \code{AcadosOcpOptions.integrator\_type} is set to \code{'ERK'}.

\textbf{Note.} Time-varying dynamics are at the moment only available via the \python{} interface and only in combination with the classical implicit Runge-Kutta (\code{'IRK'}) integrator.

%
\subsection{Discrete Dynamics}\label{sec:dynamics:discrete}
%
Another option is to provide a discrete function that maps state $x_i$, control $u_i$ and parameters $p_i$ from shooting node~$i$ to the state $x_{i+1}$ of the next shooting node $i+1$, i.e., a function
\begin{align}
x_{i+1} &= f\ind{discrete}(x_i,u_i,p_i).\label{eq:dynamics:discrete}
\end{align}
The explicit dynamics $f\ind{discrete}$ need to be provided as a \casadi{} expression and set as \code{AcadosModel.disc\_dyn\_expr}.
The discrete dynamics are used if \code{AcadosOcpOptions.integrator\_type} is set to \code{'DISCRETE'}.

%
\begin{table}[ht!]
\centering
\begin{tabular}{c@{}C{6.7cm}@{}C{5cm}@{}C{3.4cm}}
\toprule
Term & Attribute/Property & Data type & Required \\ \midrule
$x$ & \code{AcadosModel.x} & \casadi~synmbolic & \mandatory \\[3pt]
$\dot{x}$ & \code{AcadosModel.xdot} & \casadi~symbolic & \mandatory{} for \code{'IRK'}, \code{'LIFTED\_IRK'}, \code{'GNSF'}  \\[3pt]
$u$ & \code{AcadosModel.u} & \casadi~symbolic & \optional \\[3pt]
$z$ & \code{AcadosModel.z} & \casadi~symbolic & \optional \\[3pt]
$p$ & \code{AcadosModel.p} & \casadi~symbolic & \optional \\[3pt]
$p\glob$ & \code{AcadosModel.p\_global} & \casadi~symbolic & \optional \\[3pt]
$t$ & \code{AcadosModel.t} & \casadi~symbolic & \optional \\[3pt]
\midrule
integrator type & \code{AcadosOcpOptions.integrator\_type},  \code{AcadosSimOptions.integrator\_type} & str in [\code{'ERK'}, \code{'IRK'}, \code{'DISCRETE'}, \code{'LIFTED\_IRK'}, \code{'GNSF'}] & \mandatory \\[3pt]
\midrule
$ f\ind{impl}$ & \code{AcadosModel.f\_impl\_expr} & \casadi~expression & \mandatory{} for \code{'IRK'}, \code{'LIFTED\_IRK'}, \code{'GNSF'} \\[3pt]
$ f\ind{expl}$ & \code{AcadosModel.f\_expl\_expr} & \casadi~expression & \mandatory{} for \code{'ERK'} \\[3pt]
$f\ind{disc}$ & \code{AcadosModel.disc\_dyn\_expr} & \casadi~expression & \mandatory{} for \code{'DISCRETE'}\\[3pt]
\bottomrule
\end{tabular}
\caption{Dynamics definitions.} \label{tab:dynamics}
\end{table}
%
\section{Cost}\label{sec:cost}
%
The objective in~\eqref{eq:cost} comprises
\begin{itemize}
\item $ l: \mathbb{R}^{\nx}\times\mathbb{R}^{\nuu}\times\mathbb{R}^{\nz}\times\mathbb{R}\times\mathbb{R}^{\np} \rightarrow \mathbb{R}$, which is the Lagrange cost term, and
\item $ m: \mathbb{R}^{\nx}\times\mathbb{R}^{\nz}\times\mathbb{R}^{\np} \rightarrow \mathbb{R}$, which is the Mayer cost term.
\end{itemize}
There are different \acados~modules that provide different possibilities to describe these cost terms.
The cost module used for $l$ and $m$ is determined from \code{AcadosOcpCost.cost\_type\_0}, \code{AcadosOcpCost.cost\_type} and \code{AcadosOcpCost.cost\_type\_e}, respectively.


Setting the slack penalties in equation~\eqref{eq:cost} is done in the same way for all cost modules, see Table~\ref{tab:cost:slack} for an overview.
Note that the matrices $Z\Lower^*$, $Z\upper^*$ are diagonal matrices and provided to \acados{} by only specifying their diagonal values.

%
\begin{table}[ht!]
    \centering
    \begin{tabular}{cccc}
        \toprule
        Term  & Attribute/Property & Data type & Required \\ \midrule
        $ Z\Lower\initial $ & \code{AcadosOcpCost.Zl\_0} & double vector & \optional   \\[3pt]
        $ Z\upper\initial $ & \code{AcadosOcpCost.Zu\_0} & double vector & \optional   \\[3pt]
        $ z\Lower\initial $ & \code{AcadosOcpCost.zl\_0} & double vector  & \optional   \\[3pt]
        $ z\upper\initial $ & \code{AcadosOcpCost.zu\_0} & double vector  & \optional   \\[10pt]
        $ Z\Lower $          & \code{AcadosOcpCost.Zl}    & double vector  & \optional \\[3pt]
        $ Z\upper $          & \code{AcadosOcpCost.Zu}    & double vector  & \optional   \\[3pt]
        $ z\Lower $          & \code{AcadosOcpCost.zl}    & double vector  & \optional   \\[3pt]
        $ z\upper $          & \code{AcadosOcpCost.zu}    & double vector  & \optional   \\[10pt]
        $ Z\Lower\terminal $ & \code{AcadosOcpCost.Zl\_e} & double vector & \optional   \\[3pt]
        $ Z\upper\terminal $ & \code{AcadosOcpCost.Zu\_e} & double vector & \optional   \\[3pt]
        $ z\Lower\terminal $ & \code{AcadosOcpCost.zl\_e} & double vector  & \optional   \\[3pt]
        $ z\upper\terminal $ & \code{AcadosOcpCost.zu\_e} & double vector  & \optional   \\[3pt]
        \bottomrule
    \end{tabular}
    \caption{Penalties on slack variable.
    Note that the matrices $Z\Lower^*$, $Z\upper^*$ are diagonal matrices and provided to \acados{} by only specifying their diagonal values.} \label{tab:cost:slack}
\end{table}


Note that the dimensions of the slack variables $s\Lower(t)$, $s\Lower\terminal(t)$, $s\upper(t)$ and $s\upper\terminal(t)$ are determined by \acados{} from the associated matrices $Z\Lower$, $Z\upper$,  $J\ind{sh}$, $J\ind{sg}$, $J\ind{sbu}$, $J\ind{sbx}$ etc.


By default, the Lagrange cost term provided in continuous time is internally integrated using the explicit Euler method, \code{AcadosOcpOptions.cost\_discretization = 'EULER'}, which allows for a seamless OCP discretization with a nonuniform time grid.
This means that all cost terms, except for the terminal one, are weighted with the corresponding time step.
If the time steps are $\Delta t_0,\dots, \Delta t_{N-1}$, the total cost is given by $c_\text{total} = \Delta t_0 \cdot l(x_0, u_0, p_0, z_0) + \dots + \Delta t_{N-1} \cdot l(x_{N-1}, u_{N-1}, p_{N-1}, z_{N-1}) + m(x_N, p_N)$.

If a nonlinear least-squares or convex-over-nonlinear cost is used, the cost can also be integrated using the same integration scheme, which is used for the dynamics.
This is obtained for \code{AcadosOcpOptions.cost\_discretization = 'INTEGRATOR'}.

\subsection{Cost module \code{'AUTO'} \label{sec:cost:auto}}
%
Set \code{AcadosOcpCost.cost\_type\_0}, \code{AcadosOcpCost.cost\_type}, \code{AcadosOcpCost.cost\_type\_e} to \code{'AUTO'} in order to use this cost module.
In this case \acados{} detects if the cost function specified is a linear least squares term and transcribes it in the corresponding form.
Otherwise, it is formulated using the external cost module.
Table~\ref{tab:cost:auto} shows the available options.

%
\begin{table}[ht!]
    \centering
    \begin{tabular}{cccc}
        \toprule
        Term & Attribute/Property & Data type & Required \\ \midrule
        $ l $ & \code{AcadosModel.cost\_expr\_ext\_cost\_0}    & \casadi~expression   & \optional  \\
        $ l $ & \code{AcadosModel.cost\_expr\_ext\_cost}    & \casadi~expression   & \mandatory  \\
        $ m $ & \code{AcadosModel.cost\_expr\_ext\_cost\_e}    & \casadi~expression  & \optional \\
        \bottomrule
    \end{tabular}
    \caption{Cost module \code{'AUTO'} options.} \label{tab:cost:auto}
\end{table}
%


\subsection{Cost module \code{'EXTERNAL'}: External cost/Economic cost}\label{sec:cost:external}
%
Set \code{AcadosOcpCost.cost\_type\_0}, \code{AcadosOcpCost.cost\_type}, \code{AcadosOcpCost.cost\_type\_e} to \code{ext\_cost}.
See Table~\ref{tab:cost:external} for the available options.
\begin{table}[ht!]
    \centering
    \begin{tabular}{cccc}
        \toprule
        Term & Attribute/Property & Data type & Required \\ \midrule
        $ l $ & \code{AcadosModel.cost\_expr\_ext\_cost}    & \casadi~expression   & \mandatory  \\
        $ m $ & \code{AcadosModel.cost\_expr\_ext\_cost\_e}    & \casadi~expression  & \mandatory \\
        \bottomrule
    \end{tabular}
    \caption{Cost module \code{'EXTERNAL'} options.} \label{tab:cost:external}
\end{table}
%
\subsection{Cost module \code{'LINEAR\_LS'}: Linear least-squares cost}\label{sec:cost:linear_ls}
%
In order to activate the linear least-squares cost module, set \code{AcadosOcpCost.cost\_type\_0}, \code{AcadosOcpCost.cost\_type}, \code{AcadosOcpCost.cost\_type\_e} to \code{'LINEAR\_LS'}.

The Lagrange cost term has the form
\begin{align}
l(x, u, z) &= \frac{1}{2} \norm{ \underbrace{V_x\, x + V_u\, u + V_z\, z}_{\displaystyle y} - y\ind{ref}}_W^2 \label{eq:cost:linear_ls:l}
\end{align}
where matrices $ V_x \in \mathbb{R}^{n_y \times n_x}$, $V_u \in \mathbb{R}^{n_y \times n_u}$ are $V_z \in \mathbb{R}^{n_y \times n_z}$ map $x$, $u$ and $z$ onto $y$, respectively, and $W \in \mathbb{R}^{n_y \times n_y}$ is the weighting matrix.
The vector $y\ind{ref} \in \mathbb{R}^{n_y}$ is the reference.

Similarly, the Mayer cost term has the form
\begin{align}
m(x, u, z) &= \frac{1}{2} \norm{ \underbrace{V_x\terminal x}_{\displaystyle y\terminal} - y\ind{ref}\terminal}_{W\terminal}^2 \label{eq:cost:linear_ls:m}
\end{align}
where matrix $ V\terminal_x \in \mathbb{R}^{n_{y\terminal} \times n_x}$ maps $x$ onto $y\terminal$ and $W\terminal \in \mathbb{R}^{n_{y\terminal} \times n_{y\terminal}}$ is the weighting matrix.
The vector $y\terminal_\textrm{ref} \in \mathbb{R}^{n_{y\terminal}}$ is the reference.

Additionally, a different cost for the initial node can be set using the same form as \eqref{eq:cost:linear_ls:l} and the appropriate fields.
See Table~\ref{tab:cost:linear_ls} for the available options of this cost module.
%
\begin{table}[ht!]
    \centering
    \begin{tabular}{cccc}
        \toprule
        Term & Attribute/Property & Data type & Required \\ \midrule
        $ V_x\initial $ & \code{AcadosOcpCost.Vx\_0}    & double matrix & \optional   \\
        $ V_u\initial $ & \code{AcadosOcpCost.Vu\_0}    & double matrix & \optional   \\
        $ V_z\initial $ & \code{AcadosOcpCost.Vz\_0}    & double matrix & \optional  \\
        $ W\initial $ & \code{AcadosOcpCost.W\_0}    & double matrix, positive semidefinite & \optional  \\
        $ y\ind{ref}\initial $ & \code{AcadosOcpCost.yref\_0}    & double vector & \optional   \\ [1em]
        $ V_x $ & \code{AcadosOcpCost.Vx}    & double matrix& \mandatory   \\
        $ V_u $ & \code{AcadosOcpCost.Vu}    & double matrix & \mandatory   \\
        $ V_z $ & \code{AcadosOcpCost.Vz}    & double matrix & \mandatory  \\
        $ W $ & \code{AcadosOcpCost.W}    & double matrix, positive semidefinite & \mandatory  \\
        $ y\ind{ref} $ & \code{AcadosOcpCost.yref}    & double vector & \mandatory   \\ [1em]
        $ V_x\terminal $ & \code{AcadosOcpCost.Vx\_e}    & double matrix & \mandatory  \\
        $ W\terminal $ & \code{AcadosOcpCost.W\_e}    & double matrix, positive semidefinite & \mandatory   \\
        $ y\ind{ref}\terminal $ & \code{AcadosOcpCost.yref\_e}   & double vector & \mandatory   \\
        \bottomrule
    \end{tabular}
\caption{Cost module \code{'LINEAR\_LS'} options.} \label{tab:cost:linear_ls}
\end{table}
%
\subsection{Cost module \code{'NONLINEAR\_LS'}: Nonlinear least-squares cost}\label{sec:cost:nonlinear_ls}
%
In order to activate the \code{nonlinear least squares} cost module, set \code{AcadosOcpCost.cost\_type\_0}, \code{AcadosOcpCost.cost\_type}, \code{AcadosOcpCost.cost\_type\_e} to \code{'NONLINEAR\_LS'}.

The nonlinear least-squares cost has the same basic form as eqns.~(\ref{eq:cost:linear_ls:l}~-~\ref{eq:cost:linear_ls:m}) of the \code{'LINEAR\_LS'} cost module.
The only difference is that $ y $ and $ y\terminal $ are defined in terms of \casadi{} expressions, instead of via matrices $ V_x $, $ V_u $, $ V_z $ and $ V_x\terminal $.
The same note about the initial node applies to this cost module as well.
%
See Table~\ref{tab:cost:nonlinear_ls} for the available options of this cost module.
%
\begin{table}[ht!]
    \centering
    \begin{tabular}{cccc}
        \toprule
        Term & Attribute/Property & Data type & Required \\ \midrule
        $ y\initial $ & \code{AcadosModel.cost\_y\_expr\_0}    & \casadi~expression  & \optional   \\
        $ W\initial $ & \code{AcadosOcpCost.W\_0}    & double matrix, positive semidefinite  & \optional   \\
        $ y\ind{ref}\initial $ & \code{AcadosOcpCost.yref\_0}    & double vector & \optional    \\ [1em]
        $ y $ & \code{AcadosModel.cost\_y\_expr}    & \casadi~expression  & \mandatory   \\
        $ W $ & \code{AcadosOcpCost.W}    & double matrix, positive semidefinite & \mandatory   \\
        $ y\ind{ref} $ & \code{AcadosOcpCost.yref}    & double vector & \mandatory    \\ [1em]
        $ y\terminal $ & \code{AcadosModel.cost\_y\_expr\_e}    & \casadi~expression  & \mandatory   \\
        $ W\terminal $ & \code{AcadosOcpCost.W\_e}    & double matrix, positive semidefinite & \mandatory   \\
        $ y\ind{ref}\terminal $ & \code{AcadosOcpCost.yref\_e}    & double vector  & \mandatory   \\
        \bottomrule
    \end{tabular}
    \caption{Cost module \code{'NONLINEAR\_LS'} options.} \label{tab:cost:nonlinear_ls}
\end{table}


\subsection{Cost module \code{'CONVEX\_OVER\_NONLINEAR'}:  Convex-over-nonlinear cost}\label{sec:cost:convex_over_nonlinear}

If the cost takes the form
\begin{align}
l(x, u, t, p, p\glob) = \psi(y(x, u, z, t, p, p\glob) - y_\mathrm{ref}, t, p, p\glob), \qquad m(x, p, p\glob) = \psi\terminal(y\terminal(x, t, p, p\glob) - y_\mathrm{ref}\terminal, p, p\glob),
\end{align}
with $\psi(r)$ and $\psi\terminal(r\terminal)$ convex, we say the cost has convex-over-nonlinear structure.
In this case, a Generalized Gauss-Newton Hessian might be used for the SQP subproblems \cite{Messerer2021a}, which is used whenever \code{AcadosOcpOptions.hessian\_approx = 'GAUSS\_NEWTON'}.
See Table~\ref{tab:cost:conl} for the available options of this cost module.

\textbf{Note.} Convex-over-nonlinear costs are at the moment only available via the \python{} interface.


\begin{table}[ht!]
	\centering
	\begin{tabular}{cccc}
		\toprule
		Term & Attribute/Property & Data type & Required \\ \midrule
		$ y\initial $ & \code{AcadosModel.cost\_y\_expr\_0}    & \casadi~expression  & \optional   \\[4pt]
		$ y\ind{ref}\initial $ & \code{AcadosOcpCost.yref\_0}    & double vector & \optional    \\[4pt] 
		$ r\initial $ & \code{AcadosModel.cost\_r\_in\_psi\_expr\_0}    & \casadi~symbolic & \optional
		\\[4pt]
		$\psi\initial$ & \code{AcadosModel.cost\_psi\_expr\_0}   & \casadi~expression & \optional
		\\[4pt]
		\midrule
		$ y $ & \code{AcadosModel.cost\_y\_expr}    & \casadi~expression  & \mandatory   \\[4pt]
		$ y\ind{ref} $ & \code{AcadosOcpCost.yref}    & double vector & \mandatory    \\[4pt]
		$ r$ & \code{AcadosModel.cost\_r\_in\_psi\_expr}    & \casadi~symbolic & \optional
		\\[4pt]
		$\psi$ & \code{AcadosModel.cost\_psi\_expr}   & \casadi~expression & \optional
		\\[4pt]
		\midrule
		$ y\terminal $ & \code{AcadosModel.cost\_y\_expr\_e}    & \casadi~expression  & \mandatory   \\[4pt]

		$ y\ind{ref}\terminal $ & \code{AcadosOcpCost.yref\_e}    & double vector  & \mandatory   \\[4pt]
		$ r\terminal $ & \code{AcadosModel.cost\_r\_in\_psi\_expr\_e}    & \casadi~symbolic & \mandatory
\\[4pt]
$\psi\terminal$ & \code{AcadosModel.cost\_psi\_expr\_e}   & \casadi~expression & \mandatory
\\[4pt]
		\bottomrule
	\end{tabular}
	\caption{Cost module \code{'CONVEX\_OVER\_NONLINEAR'} options. Convex-over-nonlinear costs are at the moment only available via the \python{} interface.} \label{tab:cost:conl}
\end{table}

\section{Constraints}\label{sec:constraints}
%
This section is about how to define the constraints equations (\ref{eq:constraints:initial} - \ref{eq:constraints:terminal:upper_bounds:end}).

The \matlab{} interface supports the constraint module \code{BGH}, which is able to handle simple \textbf{b}ounds (on $ x $ and $ u $), \textbf{g}eneral linear constraints and general nonlinear constraints.
Meanwhile, the \python{} interface also supports the \acados{} constraint module \code{BGP}, which can handle convex-over-nonlinear constraints in a dedicated fashion.

Additionally, bounds on $u$ and general linear constraints are also enforced on the initial node by default.
On the other hand, bounds on $x$ and nonlinear constraints are fully split and have to be explicitly stated with \code{\_0} correspondence to be enforced on the initial node.

There is \href{https://github.com/acados/acados/issues/650}{preliminary support} for one-sided constraints for the QP solvers \code{HPIPM} and \code{DAQP} by setting lower/upper bounds to \code{ACADOS\_INFTY}.


%The constraint type can be set using the identifier \str{AcadosConstraints.type} and \str{AcadosConstraints.type\_e} for the path constraints and terminal constraints, respectively. The string identifier options are found in Table~\ref{tab:constr_type}. The default setting is \str{bgh}.
%\begin{table}[ht!]
%\centering
%\caption{Constraint type string identifier}\label{tab:constr_type}
%%
%\begin{tabular}{ccccc}
%    \toprule
%    & \multicolumn{4}{c}{Supported constraints} \\ \cmidrule{2-5}
%    String     & simple & polytopic & general non-   & positive \\
%    identifier & bounds & constr.   & linear constr. & definite constr.\\ \midrule
%    \code{bgh} & yes & yes & yes & no \\
%    \code{bgp} & yes & yes & yes & yes \\
%    \bottomrule
%\end{tabular}
%\end{table}
%
\subsection{Initial State Constraint}\label{sec:constraints:initial}
%
\textbf{Note.} An initial state constraint is not required.
For example, for moving horizon estimation (MHE) problems it should not be set.

Two possibilities exist to define the initial state constraint~\eqref{eq:constraints:initial}: a simple syntax and an extended syntax.

\paragraph{Simple syntax.}
Via the simple syntax the full initial state is defined, $x(0)=\overline{x}_0$.
The corresponding options are found in Table~\ref{tab:constraints:simplesyntax}.
\begin{table}[ht!]
    \centering
    \begin{tabular}{cccc}
        \toprule
        Term & Attribute/Property & Data type & Required \\ \midrule
        $ \overline{x}_0 $ & \code{AcadosConstraints.x0} & double vector & \optional \\
        \bottomrule
    \end{tabular}
    \caption{Simple syntax for setting the initial state.} \label{tab:constraints:simplesyntax}
\end{table}
%
\paragraph{Extended syntax.}
The extended syntax allows to define upper and lower bounds on a subset of states.
The options for the extended syntax are found in Table~\ref{tab:constraints:extendedsyntax}.
Note that the matrix $J\ind{bx}\initial$ is all zeros except for a single entry with the value one in each row.
The matrix is internally computed from a vector of integers specifying the 0-based column indices of the 1 entries in $J\ind{bx}\initial$.
This vector is provided to \acados{} via the attribute/property \texttt{idxbx\_0}.

As an example, consider $\texttt{idxbx\_0} = [0, 1, 3]$ and assume $n_x = 5$, i.e. the zeroth, first and third component of $x_0 \in \R^5$ are constrained.
In this case, the corresponding matrix $J\ind{bx}\initial$ would be given by
\begin{align}
J\ind{bx}\initial = 
\begin{bmatrix}
1 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & 0\\
\end{bmatrix}.
\end{align}

\begin{table}[ht!]
    \centering
    \begin{tabular}{cccc}
        \toprule
        Term & Attribute/Property & Data type & Required \\ \midrule
        $ \overline{x}_0 $ & \code{AcadosConstraints.ubx\_0} & double & \optional \\
        $ \underline{x}_0 $ & \code{AcadosConstraints.lbx\_0} & double & \optional \\
        $ J\ind{bx}\initial$ & \code{AcadosConstraints.idxbx\_0} & integer vector & \optional \\
        \bottomrule
    \end{tabular}
    \caption{Extended syntax for setting the initial state.} \label{tab:constraints:extendedsyntax}
\end{table}
%
\subsection{Path Constraints and Terminal Constraints}\label{sec:constraints:path}
%
Table~\ref{tab:constraints:path} and ~\ref{tab:constraints:terminal} show the options for defining path constraints, equations~(\ref{eq:constraints:path:lower_bounds:start}) ~-~(\ref{eq:constraints:path:upper_bounds:end}), and terminal constraints, equations~(\ref{eq:constraints:terminal:lower_bounds:start}) ~-~(\ref{eq:constraints:terminal:upper_bounds:end}), respectively.

Note that the matrices $J_{\star}$ are all zeros except for a single entry with the value one in each row.
The matrices are computed from vectors of integers, provided to \acados{} via the attributes/properties \texttt{idx}$\star$, specifying the 0-based column indices of the 1 entries in $J_{\star}$.
We refer to Section~\ref{sec:constraints:initial} for an example.


The matrices are described as follows:
\begin{itemize}
    \item $J\ind{sh}$ maps lower slack vectors $s\ind{l,h}(t)$ and upper slack vectors $s\ind{u,h}(t)$ onto the nonlinear constraint expressions $h(x,u,p, p\glob)$.
    \item $J\ind{bx}$, $J\ind{bu}$ map $x(t)$ and $u(t)$ onto their bounds vectors $\underline{x}$, $\overline{x}$ and $\underline{u}$, $\overline{u}$, respectively.
    \item $J\ind{sbx}$, $J\ind{sbu}$ map lower slack vectors $s\ind{l,bx}(t)$, $s\ind{l,bu}(t)$ and upper slack vectors $s\ind{u,bx}(t)$, $s\ind{u,bu}(t)$ onto $x(t)$ and $u(t)$, respectively.
    \item $J\ind{sg}$ maps lower slack vectors $s\ind{l,g}(t)$ and upper slack vectors $s\ind{u,g}(t)$ onto lower and upper equality bounds $\underline{g}$, $\overline{g}$, respectively.
    \item $C$, $D$ map $x(t)$ and $u(t)$ onto lower and upper inequality bounds $\underline{g}$, $\overline{g}$ (polytopic constraints).
    \item $J\ind{sh}\initial$ maps lower slack vectors $s\ind{l,h}\initial$ and upper slack vectors $s\ind{u,h}\initial$ onto the nonlinear initial constraint expressions $h\initial(x(0),u(0),p, p\glob)$.
\end{itemize}

Similarly for the terminal constraints:
\begin{itemize}
	\item $J\ind{sh}\terminal$ maps lower slack vectors $s\ind{l,h}\terminal(t)$ and upper slack vectors $s\ind{u,h}\terminal(t)$ onto nonlinear terminal constraint expressions $h\terminal(x(T), p, p\glob)$.
	\item $J\ind{bx}\terminal$ maps $x(T)$ onto its bounds vectors $\underline{x}\terminal$ and $\overline{x}\terminal$.
	\item $J\ind{sbx}\terminal$ maps lower slack vectors $s\ind{l,bx}\terminal$ and upper slack vectors $s\ind{u,bx}\terminal$ onto $x(T)$.
	\item $J\ind{sg}\terminal$ maps lower slack vectors $s\ind{l,g}\terminal(t)$ and upper slack vectors $s\ind{u,g}\terminal(t)$ onto lower and upper equality bounds $\underline{g}\terminal$, $\overline{g}\terminal$, respectively.
	\item $C\terminal$ maps $x(T)$ onto lower and upper inequality bounds $\underline{g}\terminal$, $\overline{g}\terminal$ (polytopic constraints).
\end{itemize}
%
%
\begin{table}[ht!]
    \centering
    \begin{tabular}{cccc}
        \toprule
        Term & Attribute/Property & Data type & Required \\ \midrule
        $J\ind{bx}$ & \code{AcadosConstraints.idxbx}    & integer vector & \optional  \\
        $\overline{x} $  & \code{AcadosConstraints.ubx}     & double vector  & \optional   \\
        $\underline{x} $    & \code{AcadosConstraints.lbx}     & double vector  & \optional  \\[1em]
        $J\ind{bu}$ & \code{AcadosConstraints.idxbu}    & integer vector   & \optional    \\
        $\overline{u} $         & \code{AcadosConstraints.ubu}     & double vector  & \optional   \\
        $\underline{u} $    & \code{AcadosConstraints.lbu}     & double vector   & \optional   \\ [1em]
        $C$ & \code{AcadosConstraints.C}    & double matrix & \optional \\
        $D $    & \code{AcadosConstraints.D}     & double matrix & \optional \\
        $\overline{g} $         & \code{AcadosConstraints.ug}     & double  vector & \optional   \\
        $\underline{g} $    & \code{AcadosConstraints.lg}     & double  vector & \optional    \\ [1em]
        $ h\initial $ & \code{AcadosModel.con\_h\_expr\_0}    & \casadi~expression  & \optional   \\
        $\overline{h}\initial $         & \code{AcadosConstraints.uh\_0}     & double  vector & \optional   \\
        $\underline{h}\initial $    & \code{AcadosConstraints.lh\_0}     & double  vector  & \optional   \\ [1em]
        $ h $ & \code{AcadosModel.con\_h\_expr}    & \casadi~expression  & \optional   \\
        $\overline{h} $         & \code{AcadosConstraints.uh}     & double  vector & \optional   \\
        $\underline{h} $    & \code{AcadosConstraints.lh}     & double  vector  & \optional   \\ [1em]
        $ J\ind{sbx} $ & \code{AcadosConstraints.idxsbx} & integer vector& \optional  \\
        $ J\ind{sbu}$ & \code{AcadosConstraints.idxsbu} & integer  vector& \optional \\
        $ J\ind{sg} $ & \code{AcadosConstraints.idxsg} & integer vector& \optional  \\
        $ J\ind{sh} $ & \code{AcadosConstraints.idxsh} & integer vector& \optional  \\
        $ J\ind{sh}\initial$ & \code{AcadosConstraints.idxsh\_0}  & integer vector & \optional  \\
        \bottomrule
    \end{tabular}
    \caption{Path constraints options.
    Note that bounds on $u$ and general linear constraints are also enforced on the initial node by default.
    On the other hand, bounds on $x$ and nonlinear constraints are fully split and have to be explicitly stated with \code{\_0} correspondence to be enforced on the initial node.} \label{tab:constraints:path}
\end{table}


\begin{table}[ht!]
    \centering
    \begin{tabular}{cccc}
        \toprule
        Term & Attribute/Property & Data type & Required \\ \midrule
        $J\ind{bx}\terminal$ & \code{AcadosConstraints.idxbx\_e}    & integer vector   & \optional   \\
        $\overline{x}\terminal $         & \code{AcadosConstraints.ubx\_e}     & double  vector  & \optional  \\
        $\underline{x}\terminal $    & \code{AcadosConstraints.lbx\_e}     & double  vector  & \optional   \\ [1em]
        $ C\terminal $ & \code{AcadosConstraints.C\_e}    & double matrix  & \optional   \\
        $\overline{g}\terminal $         & \code{AcadosConstraints.ug\_e}     & double vector   & \optional  \\
        $\underline{g}\terminal $    & \code{AcadosConstraints.lg\_e}     & double vector   & \optional   \\ [1em]
        $ h\terminal $ & \code{AcadosModel.con\_h\_expr\_e}    & \casadi~expression   & \optional  \\
        $\overline{h}\terminal $         & \code{AcadosConstraints.uh\_e}     & double vector  & \optional   \\
        $\underline{h}\terminal $    & \code{AcadosConstraints.lh\_e}     & double vector   & \optional   \\ [1em]
        $ J\ind{sbx}\terminal$ & \code{AcadosConstraints.idxsbx\_e} & integer vector   & \optional \\
        $ J\ind{sg}\terminal$ & \code{AcadosConstraints.idxsg\_e} & integer vector & \optional  \\
        $ J\ind{sh}\terminal$ & \code{AcadosConstraints.idxsh\_e} & integer vector  & \optional  \\
        \bottomrule
    \end{tabular}
    \caption{Terminal constraints options.} \label{tab:constraints:terminal}

\end{table}


\section{Solver Options}\label{sec:solver}


Tables \ref{tab:solver_options}, \ref{tab:solver_options:qp_solver_option} and \ref{tab:solver_options:regularize_method} show some of the available options.
This list is however not up to date.
We recommend to check the \href{https://docs.acados.org/python_interface/index.html#acados_template.acados_ocp_options.AcadosOcpOptions}{docs page} generated from the docstrings in~\python, as well as the definition of the class \code{AcadosOcpOptions} available both in \matlab{} and \python{}, for a full list of the available options.


Note that some options of the solver can be modified after its creation. Some options can only be set before the solver is created, especially options that influence the memory requirements of the OCP solver, such as the modules used in the formulation, the QP solver, etc.

%
%\begin{landscape}
\begin{table}
    \centering
    \small

    \begin{tabular}{L{4.8cm}@{}c@{}c@{}C{9.5cm}}
        \toprule
        {Attribute/Property} & Type & Default & {Description} \\ \midrule
        \multicolumn{4}{l}{\emph{Code generation}} \\
        \code{compile\_interface} & string & \str{auto} & in (\str{auto}, \str{true}, \str{false}), \matlab{} only! \\
        \midrule

		\multicolumn{4}{l}{\emph{Shooting nodes}} \\
		\code{tf} & double & & prediction horizon (denoted with $T$ in this document) \\
        \code{N\_horizon} & int $>1$ &  & uniform grid: number of shooting nodes; acts together with end time/length of prediction horizon \code{tf}. \\
        % set one of the following for nonuniform grid
        \code{shooting\_nodes}& doubles & \code{[]} & nonuniform grid option 1: direct definition of the shooting node times \\
        \code{time\_steps} & doubles & \code{[]} & {nonuniform grid option 2: definition of deltas between shooting nodes}\\
        \midrule

        \multicolumn{4}{l}{\emph{Integrator}} \\
        \code{integrator\_type} & string & \str{ERK} & in (\str{ERK}, \str{IRK}, \str{LIFTED\_IRK}, \str{GNSF}) \\
        \code{sim\_method\_num\_stages} & int & $4$ & Runge-Kutta int.\ stages: ($1$)~RK1, ($2$)~RK2, ($4$)~RK4\\
        \code{sim\_method\_num\_steps} & int & $1$\\
        \code{sim\_method\_newton\_iter} & int & $3$\\
        \code{sim\_method\_detect\_gnsf} & string & \str{true}\\
        \midrule

        \multicolumn{4}{l}{\emph{NLP solver}} \\
        \code{nlp\_solver\_type} & string & \str{SQP} & in (\str{SQP}, \str{SQP\_RTI}, \str{DDP})\\
        \code{nlp\_solver\_max\_iter} & int $>1$ & $100$ & maximum number of NLP iterations\\
        \code{nlp\_solver\_tol\_stat} & double & $10^{-6}$ & stopping criterion \\
        \code{nlp\_solver\_tol\_eq}   & double & $10^{-6}$ & stopping criterion \\
        \code{nlp\_solver\_tol\_ineq} & double & $10^{-6}$ & stopping criterion \\
        \code{nlp\_solver\_tol\_comp} & double & $10^{-6}$ & stopping criterion \\
        \code{nlp\_solver\_ext\_qp\_res} & int & $0$ & compute QP residuals at each NLP iteration \\
        \code{nlp\_solver\_step\_length} & double & $1.0$ & fixed step length in SQP algorithm \\
        \code{nlp\_solver\_warm\_start\_first\_qp} & bool & false & warm start even in the first SQP iteration \\
        \midrule

        \multicolumn{4}{l}{\emph{QP solver}} \\
        \code{qp\_solver} & string & $\longrightarrow$ & Defines the quadratic programming solver and condensing strategy. See Table~\ref{tab:solver_options:qp_solver_option}\\

        \code{qp\_solver\_iter\_max} & int & $50$ & maximum number of iterations per QP solver call\\
        \code{qp\_solver\_cond\_N} & int & \code{N\_horizon} & new horizon after partial condensing; no condensing by default\\
        \code{qp\_solver\_cond\_ric\_alg} & int & $0$ & factorize hessian in the condensing: ($0$) no, ($1$) yes \\
        \code{qp\_solver\_ric\_alg} & int & $0$ & \href{https://docs.acados.org/python_interface/index.html#acados_template.acados_ocp_options.AcadosOcpOptions.qp_solver_ric_alg}{HPIPM specific} \\
        \code{qp\_solver\_warm\_start} & int & $0$ & ($0$)~cold start, ($1$)~warm start primal variables, ($2$)~warm start both primal and dual variables \\

        \midrule
                % globalization
        \multicolumn{4}{l}{\emph{Globalization}} \\
        \code{globalization} & string & \str{FIXED\_STEP} & globalization strategy in (\str{FIXED\_STEP}, \str{MERIT\_BACKTRACKING}), note that \code{MERIT\_BACKTRACKING} is a preliminary implementation.\\
        \code{alpha\_min} & double & $0.05$ & minimum step-size, relevant for globalization  \\
        \code{alpha\_reduction} & double & $0.7$ &  step-size reduction factor, relevant for globalization  \\
        \midrule
        \multicolumn{4}{l}{\emph{Hessian approximation}} \\
        {\code{hessian\_approx}} & string & \str{GAUSS\_NEWTON} & use exact Hessian or Gauss-Newton approximation, (\str{EXACT}, \str{GAUSS\_NEWTON}) \\
        \code{regularize\_method} & string & $\longrightarrow$ & Defines the hessian regularization method. See Table~\ref{tab:solver_options:regularize_method}\\
        \code{levenberg\_marquardt} & double & $0.0$ & in case of a singular hessian, setting this $>0$ can help convergence \\
        \code{exact\_hess\_dyn} & int & $1$ & in ($0$, $1$), compute and use hessian in dynamics, only if \str{nlp\_\-solver\_\-exact\_\-hessian} = \str{true} \\
        \code{exact\_hess\_cost} & int & $1$ & in ($0$, $1$), only if \str{nlp\_solver\_exact\_hessian} = \str{true} \\
        \code{exact\_hess\_constr} & int & $1$ & in ($0$, $1$), only if \str{nlp\_solver\_exact\_hessian} = \str{true} \\
        \midrule
        \multicolumn{4}{l}{\emph{Other}} \\
        \code{print\_level} & int $\geq 0$ & $0$ & verbosity of the solver: ($0$) silent, ($>0$) print first QP problems and solution during SQP\\
        \bottomrule
    \end{tabular}
    \caption{Solver options that can be set as attributes/properties of \code{AcadosOcpOptions}.} \label{tab:solver_options}
\end{table}
%
\begin{table}
    \centering
      \begin{tabular}{cccc}
        \toprule
        Solver lib & Condensing & {Attribute/Property} & Reference \\ \midrule
        \multirow{2}{1.2cm}{\centering HPIPM} & partial & \code{PARTIAL\_CONDENSING\_HPIPM}* & \cite{Frison2020a}\\
         & full & \code{FULL\_CONDENSING\_HPIPM} & \cite{Frison2020a}\\%[1ex]
        HPMPC & partial & \code{PARTIAL\_CONDENSING\_HPMPC} & \cite{Frison2015a}\\%[1ex]
        % \multirow{2}{2cm}{\centering OOQP} & partial & \code{PARTIAL\_CONDENSING\_ooqp} \\
         % & full & \code{FULL\_CONDENSING\_ooqp} \\[1ex]
        OSQP & partial & \code{PARTIAL\_CONDENSING\_OSQP} & \cite{Stellato2020} \\
        % QORE & full & \code{FULL\_CONDENSING\_qore} \\
        qpDUNES & partial & \code{PARTIAL\_CONDENSING\_QPDUNES} & \cite{Frasch2015}\\
        qpOASES & full & \code{FULL\_CONDENSING\_QPOASES} & \cite{Ferreau2014}\\
        DAQP & full & \code{FULL\_CONDENSING\_DAQP} & \cite{Arnstrom2022} \\
        \bottomrule
        \multicolumn{3}{r}{\footnotesize * default}
    \end{tabular}
\caption{QP solver options. Note that you might need to recompile \acados{} with the corresponding flags in order to use the above QP solvers.}\label{tab:solver_options:qp_solver_option}

\end{table}
%
\begin{table}
    \centering
    \begin{tabular}{cc}
        \toprule
        Attribute/Property & Description \\\midrule
        \code{NO\_REGULARIZE}* & don't regularize \\
        \code{MIRROR} & compare \cite{Verschueren2017}
%        \href{https://cdn.syscop.de/publications/Verschueren2017.pdf}{see Verschueren2017}
        \\
        \code{PROJECT} & compare \cite{Verschueren2017} \\
        \code{PROJECT\_REDUC\_HESS} & preliminary \\
        \code{CONVEXIFY} & compare \cite{Verschueren2017}, does not work in combination with nonlinear constraints \\
        \bottomrule
        \multicolumn{2}{r}{\footnotesize * default}
    \end{tabular}
    \caption{Regularization options.}
    \label{tab:solver_options:regularize_method}
\end{table}
%\end{landscape}


\cleardoublepage

\bibliography{extracted.bib}
\end{document}
